---
format: 
  revealjs:
    slide-number: true
    # code-link: true
    highlight-style: a11y
    chalkboard: true
    theme: 
      - ../../meds-slides-styles.scss
editor_options: 
  chunk_output_type: console
---

## {#title-slide data-menu-title="Title Slide" background="#053660"} 

[EDS 430: Part 6.2]{.custom-title}

[*Testing*]{.custom-subtitle}

<hr class="hr-teal">

[Week 2 | February 2^nd^, 2024]{.custom-subtitle3}

---

##  {#testing data-menu-title="~~~ Testing ~~~" background="#047C90"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">{{< fa file-code title="a file with the code symbol, </>, on it" >}} Testing</p>
<p class="caption-text">*Creating automated tests for your apps can save time and effort, ensuring that they continue working as expected.*</p>
</div>

---

##  {#LO-testing data-menu-title="Learning Objectives - Testing"}

[{{< fa book-open title="an open book" >}} Learning Objectives for Testing]{.slide-title}

<hr>

<p class="body-text-l teal-text bottombr">After this section, you should:</p>

. . . 

[{{< fa angle-right title="a bullet point" >}}]{.teal-text} understand some of the reasons why apps break and the benefit of having automated tests

. . . 

[{{< fa angle-right title="a bullet point" >}}]{.teal-text} have a basic understanding of how to use the `{shinytest2}` package to create regression tests

. . . 

[{{< fa angle-right title="a bullet point" >}}]{.teal-text} know how to rerun tests

. . . 

<p class="body-text-l teal-text topbr">Packages introduced:</p> 

. . . 

[{{< fa box-open title="an open box" >}}]{.teal-text} `{shinytest2}`:  provides tools for creating and running automated tests on Shiny applications

---

##  {#shiny-workflow data-menu-title="Shiny workflow"}

[This workflow should look a bit familiar . . .]{.slide-title2}

<hr>

1. Add / adjust some reactivity
2. Click "Run App"
3. Manually experiment with (i.e. informally test) the new feature to see if it works 
5. Rinse & repeat

<br>

. . . 

But what if you have 20 apps? 

<br>

. . . 

Or many team members? 


<br>

. . . 

**It becomes increasingly challenging to remember all the features you need to test, or how each works.** Things can also get lost in translation with manual testing (e.g. can you explain to your coworker(s) *all* of your app's features and make sure that they manually test it properly?).

::: {.footer}
Slide adapted from Barret Schloerke's rstudio::conf(2022) talk, [`{shinytest2}`: Unit testing for Shiny applications](https://www.youtube.com/watch?v=DMgAW4m5aTI)
:::

---

##  {#why-test data-menu-title="Why test?"}

[Why test our Shiny apps?]{.slide-title}

<hr>

It's almost inevitable that our app(s) will (at some point) break -- there are lots of reasons why this happens, but to name a few:

. . . 

<p class="body-text-s topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} an upgraded R package(s) has a different behavior (this includes `{shiny}`) -- this is especially relevant for those apps hosted on servers, where server software (including packages) may be updated by system administrators</p>

. . . 

<p class="body-text-s topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} you make changes to your app (e.g. add new features, refactor code)</p>

. . . 

<p class="body-text-s topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} an external data source stops working or returns data in a different format than that expected by your app</p>

. . .

<br>

Manually testing Shiny apps is takes a lot of time and effort, is often inconsistent, and doesn't scale well (e.g. for larger apps, many apps, or for larger teams of collaborators).

. . . 

<br>

**It can save a lot of time and headache (for you *and* your collaborators) to have an automated system that checks if your app is working as expected.**

---

Different levels/types of tests:

- **Unit tests** test individual functions, components, modules of your app (e.g. can your app handle the expected data? does your user see what you expect them to see?)
- **Integration tests** test how your app works with external systems (e.g. APIs) 

<https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing>

---

##  {#shinytest2 data-menu-title="{shinytest2}"}

[Enter the `{shinytest2}` package]{.slide-title}

<hr>

The [`{shinytest2}` package](https://rstudio.github.io/shinytest2/articles/shinytest2.html) provides useful tools for **unit testing** Shiny apps. This process is also known as [**regression testing**](https://en.wikipedia.org/wiki/Regression_testing), since we'll be testing existing app behavior for consistency over time.

:::: {.columns}

::: {.column width="50%"}

<br>

<p class="body-text">From the `{shinytest2}` documentation:</p>

<p class="body-text-s quote-text-bg">"*`{shinytest2}` uses `{testthat}`’s snapshot-based testing strategy. The first time it runs a set of tests for an application, it performs some scripted interactions with the app and takes one or more snapshots of the application’s state. These snapshots are saved to disk so that future runs of the tests can compare their results to them.*"</p> 
:::

::: {.column width="50%"}
```{r}
#| eval: true
#| echo: false
#| out-width: "60%"
#| fig-align: "center"
#| fig-alt: "A hex that's split down the middle horizontally. The top half is the blue Shiny hex and the bottom half looks like the red {testthat} hex, except it reads 'test2'."
knitr::include_graphics("images/part6/shinytest2-hex.png")
```
:::

::::

[With `{shinytest2}`, we can interact with our app via the "app recorder" and our test code will be automatically generated for us. We can then rerun tests to check for consistency as we iterate on our app.]{.body-text-s}

::: {.footer}
`{shinytest2}` uses [`{chromote}`](https://rstudio.github.io/chromote/) to render your app in a headless [Chromium browser](https://www.chromium.org/chromium-projects/) -- by default, it uses Google Chrome, so make sure you have that installed on your OS! 
:::

---

##  {#setting-stage data-menu-title="Setting the stage"}

[Let's imagine . . .]{.slide-title}

<hr>

[Your boss has tasked you with building a Shiny app, and asks that you begin with a feature that greets users by name. **Create a new folder, `testing-app/`, in your GitHub repo and add the following files:**]{.body-text-s}

<!-- --- -->

<!-- ##  {#starting-app data-menu-title="Starting app"} -->

<!-- [Let's start with the following app]{.slide-title} -->

<!-- <hr> -->

::: {.panel-tabset}
## `global.R`

```{r filename="testing-app/global.R"}
#| eval: false
#| echo: true
# load libraries ----
library(shiny)
```

## `ui.R`

```{r filename="testing-app/ui.R"}
#| eval: false
#| echo: true
ui <- fluidPage(

  # Feature 1 ------------------------------------------------------------------

  h3("Feature 1"),

  # fluidRow (Feature 1: greeting) ----
  fluidRow(

    # greeting sidebarLayout ----
    sidebarLayout(

      # greeting sidebarPanel ----
      sidebarPanel(

        textInput(inputId = "name_input",
                  label = "What is your name?"),

        actionButton(inputId = "greeting_input",
                     label = "Greet"),

      ), # END greeting sidebarPanel

      # greeting mainPanel ----
      mainPanel(

        textOutput(outputId = "greeting_output"),

      ) # END greeting mainPanel

    ) # END greeting sidebarLayout

  ), # END fluidRow (Feature 1: greeting)
  
) # END fluidPage 
```

## `server.R`

```{r filename="testing-app/server.R"}
#| eval: false
#| echo: true
server <- function(input, output) {
  
  # Feature 1 ------------------------------------------------------------------

  output$greeting_output <- renderText({

    req(input$greeting_input) # req(): textOutput doesn't appear until button is first pressed
    paste0("Hello ", isolate(input$name_input), "!") # isolate(): prevents textOutput from updating until button is pressed again

  }) 
}
```

:::

---

##  {#run-ex1-appp data-menu-title="Run the app"}

[Manually test your app and make note of how it works]{.slide-title3}

<hr>

```{r}
#| eval: true
#| echo: false
#| out-width: "80%"
#| fig-align: "center"
knitr::include_graphics("images/part6/ex1-explore.gif")
```

<br>

. . . 

::: {.center-text}
Let's say that you are satisfied with your work (yay!) and are now ready to write some automated tests to ensure consistent behavior as you continue to build out additional features.
:::

---

[Write down your assumptions]{.slide-title}

<hr>

Before we dive into writing any tests, it's super helpful to inspect your app and, *importantly* jot down any assumptions it makes of both the inputs and outputs.

<br>

I find it easiest to consider which **actions** can be taken, and what the **expected outputs** (aka assertions) in the app's final state should be. 

<br>

```{r}
countdown::countdown(
  minutes = 2,
  # left = 0, right = 0,
  # Fanfare when it's over
  # play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```

. . . 

| Action(s)                                                                                       | Expectation(s)                                                           |
|-------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
| Type [some text value] in text box, click Greet button                                          | Greeting output is "Hello [some text value]!"                            |
| Type [some text value] in text box, click Greet button, type [some other text value] in text box, click Greet button | Greeting output is "Hello [some other text value]!" |
| Click Greet button                                                                              | Greeting output is "Hello !"                                             |

---

##  {#testing-procedure data-menu-title="Testing procedure"}

[Test your assumptions using the `{shinytest2}` workflow]{.slide-title2}

<hr>

<br>

[**Generally speaking, that workflow looks something like this:**]{.teal-text}

<br>

. . . 

[**(1)**]{.teal-text} Run `shinytest2::record_test(<app-directory>)` in your Console to launch the app recorder in a browser window

<br>

. . . 

[**(2)**]{.teal-text} Interact with your application and tell the recorder to make an expectation of the app's state, which will record all `input`, `output`, and `exported` values. 

<!-- (e.g. an expected value when inputX is updated) on the state at various points -->

<br>

. . . 

[**(3)**]{.teal-text} Give your test a unique name and quit the recorder to save and execute your tests

<br>

. . . 

::: {.center-text .body-text-m}
We'll repeat this workflow to test each of our three assumptions listed on the previous slide.
:::

---

##  {#ft1-test1 data-menu-title="Feature 1, test 1"}

[Let's test our first assumption . . .]{.slide-title}

<hr>

...which is that when a user types [some text value] into the text box and clicks the Greet button (**i.e. the actions**), the greeting output will return `Hello [some text value]!` (**i.e. the expectation**). We'll substitute a known value (e.g. "Sam") for [some text value] in our test.

<br>

:::: {.columns}

::: {.column width="50%"}
```{r}
#| eval: true
#| echo: false
#| out-width: "100%"
#| fig-align: "center"
knitr::include_graphics("images/part6/one-name-greeting.gif")
```
:::

::: {.column width="50%"}
[**Steps:**]{.teal-text}

[[**(1)**]{.teal-text} Run `shinytest2:record_test("testing-app")` in the Console]{.body-text-s}

[[**(2)**]{.teal-text} Type `Sam` into the text box > click the Greet button > click Expect Shiny Values]{.body-text-s}

[[**(3)**]{.teal-text} Give the test a unique name > click Save test and exit]{.body-text-s}

[[**(4)**]{.teal-text} The test recorder will quit, and your test will automatically execute (it should pass!)]{.body-text-s}

:::
::::

::: {.center-text .body-text-s}
Notice that your actions (e.g. typing text, clicking the button) are recorded as code in the right-hand panel -- this is your test code, and it'll be saved when you quit the recorder.
:::

<!-- --- -->

<!-- What are assumptions? -->

<!-- ```{r} -->
<!-- ex_function <- function(a, b) { -->
<!--   c <- a + b -->
<!--   return(c) -->
<!-- } -->
<!-- ``` -->

<!-- - inputs -- we want to make sure that inputs are consistent and follow the expected format -->
<!--   - # of inputs  -->
<!--   - order of inputs (if not using keyword args) -->
<!--   - type of input (e.g. is `a` a string? a number? can it be anything?) -->
<!--   - absence of inputs (e.g. are there default values) -->
<!-- - logic  -->
<!--   - does this handle the expected inputs (e.g. if i give it something that it should handle, will it do it as I expect) -->
<!--   - does it handle unexpected inputs (e.g. return NULL, throw error message) -->
<!-- - return (what does the function return?) -->
<!--   - make sure that it returns the right data type (e.g. string, numeric) -->

<!-- what different variations of my inputs impact my output? -->
<!-- - you'll never think of all variations -->

<!-- --- -->

<!-- ##  {#assumptions data-menu-title="Write down assumptions"} -->

<!-- [Write down assumptions]{.slide-title2} -->

<!-- <hr> -->

<!-- [**Example 1: Greeting**]{.body-text-m .teal-text} -->

<!-- - input: does the user supply text values? -->
<!-- - logic/output: does the app print, "Hello <input>!" -->

<!-- - Expected output: user's input is prefixed with "Hello" and suffixed with "!". The text is then displayed -->
<!-- - an assumption is that a user can input numbers, paragraphs, etc (anything that is valid as a text input) -->
<!-- - when the greet button is clicked, it'll display what the user has input (even with successive inputs) -->

<!-- [**Example 2: Upload & summarize data**]{.body-text-m .teal-text} -->

<!-- - input:  -->
<!--   - user supplies a csv file -->
<!-- - output:  -->
<!--   - if the csv column has expected column headers, it will: -->
<!--     - rename columns -->
<!--     - remove rows with missing values (NA) -->
<!--     - average values in each column -->
<!--     - return summary data frame -->
<!--   - if the csv does not have the expected column headers, it will: -->
<!--     - return a message that tells the user the file is not as expected -->
<!--   - if the csv does not have any values, it will: -->
<!--     - return a message that tells the user the file is not as expected -->
<!--   - successive csv uploads shows the most recent data -->

<!-- [**Example 3: Reactive plot**]{.body-text-m .teal-text} -->

<!-- - input:  -->
<!--   - shows the user what they can choose: the user can select `Adelie`, `Chinstrap`, and/or `Gentoo` -->
<!--   - when user chooses something, does the right thing happen - when user deselects a species, it's removed from the plot -->
<!--   - when a user selects a species, it's added to the plot  -->
<!--   - when the user deselects all, a message prompts user to select at least one species -->
<!--   - does the user see the correct default selection -- all species are selected by default -->
<!-- - output:  -->
<!--   - selected species will be plotted, deselected species will not be plotted -->
<!--   - if not species are selected, a message will alert user to select species -->

<!-- --- -->

<!-- ##  {#testing-procedure data-menu-title="Testing procedure"} -->

<!-- [Testing using `{shinytest2}`]{.slide-title} -->

<!-- <hr> -->

<!-- **Recording tests requires the following steps:** -->

<!-- . . .  -->

<!-- [[**(1)**]{.teal-text} Run `shinytest2::record_test(<app-directory>)` to launch the app recorder in a browser window]{.body-text-s} -->

<!-- . . .  -->

<!-- [[**(2)**]{.teal-text} Interact with your application and tell the recorder to make an expectation (e.g. an expected value when inputX is updated) on the state at various points]{.body-text-s} -->

<!-- . . .  -->

<!-- [[**(3)**]{.teal-text} Quit the recorder to save and execute your tests]{.body-text-s} -->

<!-- . . .  -->

<!-- <br> -->

<!-- **To test *our* app specifically, we'll do the following:** -->

<!-- [[**(1)**]{.teal-text} run `shinytest2::record_test("testing-app")` in the console to launch the recorder in a browser window]{.body-text-s} -->

<!-- [[**(2)**]{.teal-text} interact with your app by first typing a name (e.g. Sam), then pressing the "Greet" button to display the output text]{.body-text-s} -->

<!-- [[**(3)**]{.teal-text} click the **Expect Shiny values** button in the recorder app sidebar to set an expectation (this will record inputs, outputs, and exported values)]{.body-text-s} -->

<!-- [[**(4)**]{.teal-text} give your test a name in the recorder app sidebar, then click **Save test and exit** - this will save the recorded test and setup the testing infrastructure, if it doesn't exit already]{.body-text-s} -->

<!-- --- -->

<!-- ##  {#creating-test1-example data-menu-title="Creating our first test"} -->

<!-- [Creating our first test]{.slide-title} -->

<!-- <hr> -->

<!-- Following the steps on the previous slide, creating your test should look similar to this: -->

<!-- <br> -->

<!-- ```{r} -->
<!-- #| eval: true -->
<!-- #| echo: false -->
<!-- #| out-width: "100%" -->
<!-- #| fig-align: "center" -->
<!-- #| fig-alt: "A user begins recording a test by typing shinytest2::record_test('testing_app') in the RStudio console, which opens up the app in an iframe with the recorder in a pane to the right. The user types 'Sam' into the text box, clicks the 'Greet' button, then clicks 'Expect Shiny values' in the recorder. Finally, the user names and saves the test, which then runs automatically once the recorder is quit." -->
<!-- knitr::include_graphics("images/part6/sam-test.gif") -->
<!-- ``` -->

<!-- <br> -->

<!-- **Note:** Your test is automatically run as soon as you save and exit the recorder. See the results of your test in your console (it should pass!). -->

---

##  {#test-auto-executes data-menu-title="Tests auto execute"}

[Your test should automatically run (and pass!)]{.slide-title2}

<hr>

After quitting the test recorder, the following will happen: 

- [a test script will be saved in `<your-app-subdirectory>/tests/testthat/test-shinytest2.R`]{.body-text-s}
- [if you're running in the RStudio IDE, `test-shinytest2.R` will automatically open in the editor]{.body-text-s} 
- [`shinytest2::test_app()` is run behind the scenes to execute the test script]{.body-text-s}

<!-- [the test script will execute (`test_app()`, which is stored inside `tests/testthat.R`, is run behind the scenes)]{.body-text-s} -->

You should see the following in your RStudio Console: 

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
• Saving test runner: tests/testthat.R
• Saving test file: tests/testthat/test-shinytest2.R
✔ Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'
• Running recorded test: tests/testthat/test-shinytest2.R
✔ | F W  S  OK | Context
✔ |   2      1 | shinytest2 [1.4s]                                                         
───────────────────────────────────────────────────────────────────────────────────────────
Warning (test-shinytest2.R:7:3): {shinytest2} recording: one-name-greeting
Adding new file snapshot: 'tests/testthat/_snaps/one-name-greeting-001_.png'

Warning (test-shinytest2.R:7:3): {shinytest2} recording: one-name-greeting
Adding new file snapshot: 'tests/testthat/_snaps/one-name-greeting-001.json'
───────────────────────────────────────────────────────────────────────────────────────────

══ Results ════════════════════════════════════════════════════════════════════════════════
Duration: 1.5 s

[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]
```

---

##  {#test-folder data-menu-title="Explore the tests/ folder"}

[Understanding the contents of `tests/`]{.slide-title}

<hr>

The first time you record a test, `{shinytest2}` generates number of directories / subdirectories, along with a bunch of files. The next few slides dives deeper into many of these.

<br>

```{md}
#| eval: false
#| echo: true
#| code-line-numbers: false
.
├── testing-app/                                  
│   └── global.R                     
│   └── ui.R                         
│   └── server.R                      
│   └── tests/                    # generated the first time you record and save a test    
│      └── testthat.R             # see note below
│      └── testthat/     
│         └── setup-shinytest2.R  # see note below
│         └── test-shinytest2.R   # see slide 15
│         └── snaps/               
│            └── shinytest2/      
│               └── *001.json     # see slide X
│               └── *001_.png     # see slide X 
```

- [`testthat.R`: includes the code, `shinytest2::test_app()`, which is executed when you click the **Run Tests** button in RStudio]{.body-text-s}
- [`setup-shinytest2.R`: includes the code, `shinytest2::load_app_env()`, which loads any application support files (e.g. `global.R` and / or anything inside `R/`) into the testing environment]{.body-text-s}

---

##  {#test-shinytest2 data-menu-title="The test file"}

[`test-shinytest2.R` (test code)]{.slide-title}

<hr>

[All tests will be saved to `tests/testthat/test-shinytest2.R`. Yours should look similar to the code below (sans annotations). You may have a different viewport height / width (depending on the size of your viewport when you recorded your test), and if you mistyped / deleted any characters in the textInput, you'll see multiple `app$set_inputs()` statements, reflecting these actions:]{.body-text-s}

```{r filename="testing-app/tests/testthat/test-shinytest2.R"}
#| eval: false
#| echo: true
library(shinytest2)

# runs our test
test_that("{shinytest2} recording: one-name-greeting", {
  
  # start Shiny app in a new R session along with chromote's headless browser that's used to simulate user actions
  app <- AppDriver$new(name = "one-name-greeting", height = 838, width = 1298)
  
  # set the textInput (with Id `name_input`) to the value `Sam`
  app$set_inputs(name_input = "Sam")
  
  # click the actionButton (with Id `greeting_input`)
  app$click("greeting_input")
  
  # save the expected input, output, and export values to a JSON snapshot and generates a debug screenshot of the app
  app$expect_values()
})
```

::: {.center-text}
**You can think of each test as a recipe for `{shinytest2}` to follow to simulate user actions, and verify that the resulting outcomes are as expected.**
:::

<!-- ::: {.footer} -->
<!-- You're able to manually edit this test code and / or write test code from scratch, if you wish. -->
<!-- ::: -->

---

##  {#snaps data-menu-title="The _snaps/ folder"}

[The `snaps/` folder]{.slide-title}

<hr>

[When `shinytest2::test_app()` runs your test code (`test-shinytest2.R`), it plays back the specified actions (e.g. setting the textInput to `Sam`, then clicking the Greet button), and records your application's resulting state as a snapshot. Snapshots are saved to the `tests/testthat/shinytest2/_snaps/` folder. You should see two different snapshot files:]{.body-text-s}

:::: {.columns}

::: {.column width="50%"}
::: {.center-text .body-text-s}
`one-name-greeting-001_.png`, a debug screenshot of the app when `app$expect_values()` was called.
```{r}
#| eval: true
#| echo: false
#| out-width: "80%"
#| fig-align: "center"
knitr::include_graphics("images/part6/one-name-greeting.png")
```
:::
:::

::: {.column width="50%"}
::: {.center-text .body-text-s}
`one-name-greeting-001.json`, a [JSON](https://www.json.org/json-en.html) representation of the state of the app when `app$expect_values()` was called
:::

```{json}
#| eval: false
#| echo: true
{
  "input": {
    "greet": 1,
    "name": "Sam"
  },
  "output": {
    "greeting": "Hello Sam!"
  },
  "export": {

  }
}
```
:::

::::

<!-- ::: {.panel-tabset} -->

<!-- ## `*_.png` -->

<!-- [**(located at `~/<app-directory>/tests/testthat/_snaps/shinytest2/*_.png`)**; This is a screenshot of your app from when `app$expect_values()` was called -- this file should be tracked using git so that you know how your app visually changes over time. My `.png` file looks like this:]{.body-text-s} -->

<!-- <br> -->

<!-- ```{r} -->
<!-- #| eval: true -->
<!-- #| echo: false -->
<!-- #| out-width: "40%" -->
<!-- #| fig-align: "center" -->
<!-- #| fig-alt: "A screenshot from my app, with the text 'Sam' printed in the text input box beneath the prompt, 'What is your name?'. Below the text box is a button that says 'Greet'. Below that, the text, 'Hello Sam!' is printed." -->
<!-- knitr::include_graphics("images/part6/sam-test-001_.png") -->
<!-- ``` -->

<!-- ## `*.json` -->

<!-- [This is a [JSON](https://www.json.org/json-en.html) representation of the state of the app when `app$expect_values()` was called -- you'll see the state of all input, output, and export values at the time of the snapshot (we don't have any exports in our example app, but we do have a name input and a greeting output). This file should be tracked with git so that you have a record of your expected results. Your `.json` file should look something like this:]{.body-text-s} -->

<!-- ```{json filename="~/testing-app/tests/testthat/_snaps/shinytest2/*.json"} -->
<!-- #| eval: false -->
<!-- #| echo: true -->
<!-- { -->
<!--   "input": { -->
<!--     "greet": 1, -->
<!--     "name": "Sam" -->
<!--   }, -->
<!--   "output": { -->
<!--     "greeting": "Hello Sam!" -->
<!--   }, -->
<!--   "export": { -->

<!--   } -->
<!-- } -->
<!-- ``` -->

<!-- ::: -->

Future test runs are compared against snapshots to determine if your app is performing as your tests expects.

---

Please also download [these CSV files](https://drive.google.com/drive/folders/1fMpPHFgYQhfZH0dmbUtWbxSoHYfFgUZD?usp=sharing) and save them to your Desktop (we'll use these later).

---

##  {#testing-tips data-menu-title="Testing tips"}

[Tips for testing]{.slide-title}

<hr>

<p class="body-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} Record subsequent tests following the same workflow, giving each a unique name. Run `test_app("path/to/app")` to run all test scripts in your app's `tests/testhat/` directory.</p>

<p class="body-text">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} **Use `record_test()` fairly often** -- Barret Schloerke argues that you should make a test recording for each feature of your app (many little recordings are encouraged!)</p>

<p class="body-text topbr">[{{< fa angle-right title="a bullet point" >}}]{.teal-text} **Limit testing to objects under your control.** For example, let's say you have a reactive data frame that you then send to a `DT::datatable` -- if package maintainers update the `DT` package, your output might change which could lead to false positive failed tests. Instead, test just your data frame that gets sent to `DT`.</p>

. . .

<br>

<center><p class="body-text-l teal-text">This is only a brief intro to `shinytest2`! Dig into the [documentation](https://rstudio.github.io/shinytest2/index.html) to learn more.</p></center>

---

##  {#end data-menu-title="~~~ BREAK ~~~" background="#047C90"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">End part 6.2</p>
<p class="caption-text">***Up next:** streamlinging code*</p>
</div>

```{r}
countdown::countdown(
  minutes = 5,
  # left = 0, right = 0,
  # Fanfare when it's over
  # play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```

